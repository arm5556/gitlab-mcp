---
description: 
globs: 
alwaysApply: true
---
# User Rules & Workflow Patterns

## Development Rules

### Code Quality & Constants
- **Prefer constants over magic numbers** - Use named constants instead of hardcoded values
- **Avoid config files unless explicitly requested** - Use constants in code by default
- **Let user review before committing** - Don't auto-commit changes unless explicitly instructed
- **No commits to protected branches** - Avoid committing to `master`, `main`, `develop` branches

### Git Workflow
- **Use specific git commands** - Avoid `git add .` as it may include unrelated files
- **Skip hooks when needed** - Use `git commit --no-verify` to skip pre-commit hooks
- **Switch to MR branch first** - When working with GitLab URLs, ensure to switch to the branch in the MR
- **Don't clone repos** - Ask user to switch to the right folder instead of cloning

### Testing & Verification
- **Run unit tests before commit** - Verify results with tests before committing changes
- **Use sbt -client for better performance** - Except when using cucumber testing
- **Test organization** - Place tests in appropriate subdirectories under `tests/`

### Task Management
- **Use tools for complex jobs** - Jobs with more than 5 tasks should use task management tools
- **Update job status properly** - Follow flow: `coding_done` → `testing_done` → `changes_pushed` → `done_ALL`
- **Group related changes** - When inserting tasks, group related changes for efficiency
- **Include required details** - Tasks should include: 1) discussion ID, 2) line of code, 3) file path
- **Quality assurance tasks last** - Always add QA tasks at the end: 1) run unit test, 2) verify completed tasks cover discussions

### Branch Management
- **Create meaningful branch names** - When user asks for new branch without specifying name, pick descriptive names
- **Switch and pull pattern (snp)** - `snp = switch and pull given branch`
- **Commit and push pattern (cnp)** - `cnp = commit changes and push it, ensure to run scalafmtAll before`

## MR (Merge Request) Management

### Working with MRs
- **Switch to MR branch first** - Always ensure you're on the correct branch when working with MR
- **Use branch name or IID** - MR tools support both merge request IID and branch name
- **Add response tasks for comments** - When fixing MR comments, add task to respond to discussions

### Task Management for MRs
- **Call get pending tasks** - Use `limit=15` to work on manageable chunks
- **Complete tasks by IDs** - Call complete tasks by IDs after finishing to keep track for analytics
- **Avoid overusing tools** - Balance between automation and manual oversight

## GitLab API Best Practices

### Vulnerability Management
- **Use enhanced vulnerability tools** - Prefer `get_vulnerabilities_by_ids` for comprehensive data
- **Single IDs as arrays** - Pass single vulnerability IDs as arrays: `["12345"]`
- **Location and solution data** - Enhanced tools provide file paths, line numbers, and upgrade instructions

### Error Handling
- **Provide context in errors** - Include project and operation context when errors occur
- **Handle rate limits** - Be aware of GitLab API rate limiting and handle gracefully
- **Validate tokens** - Always ensure GitLab token is available before API operations

## Development Environment

### Build & Test Commands
```bash
npm run build          # Always build before testing
sbt -client            # Use for better performance (except cucumber)
scalafmtAll           # Run before committing Scala code
```

### Environment Variables
- `GITLAB_PERSONAL_ACCESS_TOKEN` - Required for API access
- `GITLAB_API_URL` - GitLab instance URL
- `GITLAB_READ_ONLY_MODE` - Limit to read-only operations

## Common Patterns

### Vulnerability Workflow
1. Use `get_vulnerabilities_by_ids` with array of IDs
2. Extract location information (file, line numbers)
3. Get solution text with upgrade instructions
4. Identify CVE numbers and scanner information

### MR Comment Workflow
1. Switch to MR branch using `snp` pattern
2. Get MR discussions using `mr_discussions` tool
3. Make necessary code changes
4. Add response comment using `create_merge_request_note`
5. Commit and push using `cnp` pattern

### Task Management Workflow
1. Get pending tasks (limit=15)
2. Group related changes for efficiency
3. Include discussion ID, line numbers, file paths
4. Complete tasks and update status
5. Add QA tasks at the end (unit tests, verification)

## File Organization

### Test Files
- `tests/vulnerabilities/` - Vulnerability-related tests
- `tests/merge-requests/` - MR functionality tests  
- `tests/tools/` - Tool validation tests
- `tests/general/` - General utility tests

### Code Structure
- `index.ts` - Main server implementation
- `schemas.ts` - Zod schemas and TypeScript types
- `.cursor/rules/` - AI agent context and rules

## Quality Assurance

### Before Committing
1. Run unit tests to verify functionality
2. Check that changes address all discussion points
3. Ensure code follows project conventions
4. Run formatting tools (scalafmtAll for Scala)
5. Use `git commit --no-verify` if hooks need to be skipped

### Code Review
- Let user review changes before committing
- Provide clear commit messages
- Reference issue/MR numbers when applicable
- Group related changes in single commits
